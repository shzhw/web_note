## 位运算 6
#### >>  右移
- value >> num
num 指定要位移值 value 移动的位数
>右移的规则只记住一点：符号位不变，左边补上符号位
- 运算规则
按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。

#### <<  左移  
- 相当于 *2
- 其功能把 `<<` 左边的运算数的各二进位全部左移若干位，由 `<<` 右边的数指定移动的位数，**高位**丢弃，**低**位补0

#### &  按位与
- 按位与运算符 `&` 是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位**均为1时**，结果位才为1，否则为0
- 9 & 5 == 1

#### |  按位或
- 按位或运算符 `|` 是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位**有一个为1时**，结果位就为1
- 9 | 5 == 13

#### ^  按位异或
- 按位异或运算符 `^` 是双目运算符。其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位**相异**时，结果为1
- 9 ^ 5 == 12

#### ~  取反


## 进制
#### 十进制 -- 二进制
- 正整数转二进制
  + 除二取余，然后倒序排列，高位补零
  + 42 --> 00101010
- 负整数转二进制
  + 先是将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一
  + -42 --> 42转成二进制 取反 --> 11010101 --> +1 --> 11010110
- 小数转二进制
  + 整数部分<1
    对小数点以后的数乘以2，有一个结果吧，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了。然后把取的整数部分按先后次序排列就OK了，就构成了二进制小数部分的序列
  + 0.125 --> 0.001
  + 整数部分>1
    整数转换成二进制，小数转换成二进制，然后加在一起就OK了
  + 6.125 --> 110.001
- 整数二进制 --> 十进制
  + 补齐位数，首位如果是`0`就代表是`正`整数，如果首位是`1`则代表是`负`整数
  + 1010 --> 00001010 --> 0*2^0 + 1*2^1 + 0*2^2 + 1*s^3 --> 10
  + 首位为1时，就需要先取反再换算
- 小数二进制 --> 十进制
  + 0.1101 --> 0*2^0 + 1*2^-1 + 1*2^-2 + 0*2^-3 + 1*2^-4



## Unicode 和 数字
#### formCharCode() Unicode数字 转成 字符串
- `formCharCode(numX1,numX2,numX3...);`

#### charCodeAt() 指定位置的字符的 Unicode 编码
- `str.charCodeAt(index);`

#### charAt() 返回指定位置的字符
- `str.charAt(index);`